<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ğŸ“‚ç®—æ³•ç¬”è®° on Chao&#39;s Blog</title>
    <link>https://ccbyte.github.io/posts/algorithm/</link>
    <description>Recent content in ğŸ“‚ç®—æ³•ç¬”è®° on Chao&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 30 Aug 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://ccbyte.github.io/posts/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>äºŒåˆ†æ³•</title>
      <link>https://ccbyte.github.io/2020/binary-search/</link>
      <pubDate>Sun, 30 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ccbyte.github.io/2020/binary-search/</guid>
      <description>äºŒåˆ†æ³• äºŒåˆ†æŸ¥æ‰¾ åŸºäºæœ‰åºåºåˆ—çš„æŸ¥æ‰¾æ–¹æ³•ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºO(logn)
#include&amp;lt;cstdio&amp;gt; int binarySearch(int A[], int left, int right, int x) { int mid; // leftå’Œrightä¸­ç‚¹  while (left &amp;lt;= right) { mid = (left + right) / 2; // å–ä¸­ç‚¹  if(A[mid] == x) return mid; else if(A[mid] &amp;gt; x) right = mid - 1; else left = mid + 1; } return -1; // æŸ¥æ‰¾å¤±è´¥è¿”å›-1 } int main() { const int n = 10; int A[n] = { 1, 3, 4, 6, 7, 8, 10, 11, 12, 15 }; printf(&amp;#34;%d, %d\n&amp;#34;, binarySearch(A, 0, n-1, 6), binarySearch(A, 0, n-1, 9)); return 0; } äºŒåˆ†æ³•æ‹“å±• å¿«é€Ÿå¹‚ </description>
    </item>
    
    <item>
      <title>é€’å½’</title>
      <link>https://ccbyte.github.io/2020/recursion/</link>
      <pubDate>Tue, 07 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ccbyte.github.io/2020/recursion/</guid>
      <description>é€’å½’ ä¸¤ä¸ªé‡è¦æ¦‚å¿µï¼š
 é€’å½’è¾¹ç•Œ é€’å½’å¼ï¼ˆé€’å½’è°ƒç”¨ï¼‰  å…¶ä¸­çš„é€’å½’å¼æ˜¯å°†åŸé—®é¢˜åˆ†æˆè‹¥å¹²å­é—®é¢˜çš„æ‰‹æ®µï¼Œé€’å½’è¾¹ç•Œåˆ™æ˜¯åˆ†è§£çš„å°½å¤´ã€‚ï¼ˆå¦‚æœæ²¡æœ‰å°½å¤´å°±ä¼šæ— é™åˆ†è§£ï¼‰
ğŸŒ° ä½¿ç”¨é€’å½’æ±‚è§£nçš„é˜¶ä¹˜ ğŸŒ° æ±‚Fibonacciæ•°åˆ—çš„ç¬¬né¡¹ ğŸŒ° å…¨æ’åˆ—ï¼ˆFull Permutationï¼‰ ä¸€ä¸ªæ•°åˆ—æ‰€æœ‰çš„æ’åˆ—æ–¹å¼çš„é›†åˆç§°ä¸ºå…¨æ’åˆ—ã€‚
ã€ä¸¾ä¾‹ã€‘å¦‚1,2,3çš„å…¨æ’åˆ—ï¼š(1,2,3),(1,3,2),(2,1,3),(2,3,1),(3,1,2),(3,2,1)ï¼›ï¼ˆæŒ‰å­—å…¸åºï¼‰
ã€ç›®çš„ã€‘æŒ‰å­—å…¸åºä»å°åˆ°å¤§è¾“å‡ºå…¨æ’åˆ—ï¼šå…¶ä¸­(a1,a2,&amp;hellip;an)çš„å­—å…¸åºå°äº(b1,b2,&amp;hellip;bn)ï¼Œæ˜¯æŒ‡å­˜åœ¨ä¸€ä¸ªiï¼Œä½¿å¾—a1=b1,a2=b2,â€¦â€¦,ai&amp;lt;biæˆç«‹ï¼›
#include&amp;lt;cstdio&amp;gt;const int maxn = 11; // max number int n, p[maxn], hashTable[maxn] = {false}; // p: Now permutation, hashTable: Record whether x has been placed in p  void generateP(int index) { if(index == n + 1) // recursion boundary  { for(int i = 1; i &amp;lt;= n; i++) // print result  { printf(&amp;#34;%d&amp;#34;, p[i]); } printf(&amp;#34;\n&amp;#34;); return; } for(int x = 1; x &amp;lt;= n; x++) { if(hashTable[x] == false) // x hasn&amp;#39;t been used  { p[index] = x; // use x (place x in p)  hashTable[x] = true; // x has been used  generateP(index + 1); // recursion (resolve the sub-problems when p[index] = x)  hashTable[x] = false; // restore the x (resolved)  } } } int main() { n = 3; // want to print 1~3 full permutation  generateP(1); // recursion start from 1  return 0; } ğŸŒ° nçš‡åé—®é¢˜ #include&amp;lt;cstdio&amp;gt;#include&amp;lt;cmath&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std; const int maxn = 11; int n, P[maxn], hashTable[maxn] = {false};// p: å½“å‰æ’åˆ—,Â hashTable:Â è®°å½•xæ˜¯å¦å·²ç»æ”¾å…¥pint counter = 0;  void generateP1(int index){ /* é€’å½’è¾¹ç•Œ ç”Ÿæˆä¸€ä¸ªæ’åˆ— */ if(index == n + 1){ bool flag = true; // å½“å‰æ’åˆ—åˆæ³•  /* éå†ä»»æ„ä¸¤ä¸ªçš‡å */ for(int i = 1; i &amp;lt;= n; i++){ for(int j = i + 1; j &amp;lt;= n; j++){ for(int j = i + 1; j &amp;lt;= n; j++){ if(abs(i - j) == abs(P[i] - P[j])){ // åœ¨åŒä¸€å¯¹è§’çº¿ä¸Š  flag = false; // å†²çª  } } } } if(flag) counter++; return; } for(int x = 1; x &amp;lt;= n; x++){ if(hashTable[x] == false){ P[index] = x; hashTable[x] = true; generateP1(index + 1); hashTable[x] = false; } } } void generateP2(int index){ /* é€’å½’è¾¹ç•Œ */ if(index == n + 1){ counter++; return; } /* éå†è¡Œ */ for(int x = 1; x &amp;lt;= n; x++){ /* è‹¥ç¬¬xè¡Œè¿˜æ²¡çš‡å */ if(hashTable[x] == false){ bool flag = true; // flagä¸ºtrueè¡¨ç¤ºä¸ä¼šä¸ä¹‹å‰çš„çš‡åå†²çª  /* éå†ä¹‹å‰çš„çš‡å */ for(int pre = 1; pre &amp;lt; index; pre++){ /* åˆ¤æ–­æ˜¯å¦å†²çª */ if(abs(index - pre) == abs(x - P[pre])){ flag = false; // å†²çªï¼ˆåœ¨åŒä¸€å¯¹è§’çº¿ï¼‰  break; // è·³å‡ºå¾ªç¯  } } /* æ— å†²çªåˆ™æ”¾ç½®çš‡å */ if(flag) { P[index] = x; hashTable[x] = true; //å ç”¨ç¬¬xè¡Œ  generateP2(index + 1); // å¤„ç†ä¸‹ä¸€è¡Œï¼ˆå­é—®é¢˜ï¼‰  hashTable[x] = false; // å­é—®é¢˜éƒ½å¤„ç†å®Œäº†ï¼Œè¿˜åŸç¬¬xè¡ŒçŠ¶æ€  } } } } int main(){ n = 8; // æ£‹ç›˜å¤§å° n*n  generateP2(1); //ä»P[1]å¼€å§‹å¡«  printf(&amp;#34;%d\n&amp;#34;, counter); return 0; }  nçš‡åé—®é¢˜æ–¹æ³•æ€»ç»“</description>
    </item>
    
    <item>
      <title>è´ªå¿ƒ</title>
      <link>https://ccbyte.github.io/2020/greedy/</link>
      <pubDate>Tue, 23 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ccbyte.github.io/2020/greedy/</guid>
      <description>è´ªå¿ƒ è´ªå¿ƒæ˜¯åªè€ƒè™‘å½“ä¸‹çš„ä¸€ç§å±€éƒ¨æœ€ä¼˜ï¼ˆæˆ–è¾ƒä¼˜ï¼‰ï¼Œæ¥ä½¿å…¨å±€ç»“æœè¾¾åˆ°æœ€ä¼˜ï¼ˆæˆ–è¾ƒä¼˜ï¼‰çš„ç­–ç•¥ã€‚ è¯æ˜ç­–ç•¥æ˜¯æœ€ä¼˜ï¼ˆæˆ–è¾ƒä¼˜ï¼‰çš„ï¼šåè¯æ³•ã€æ•°å­¦å½’çº³æ³•ã€è¯æ˜è¾ƒå¤æ‚ï¼Œè‹¥æœ‰ä¸é”™çš„æ€è·¯ä¸”æ— æ³•æ‰¾åˆ°åä¾‹ï¼Œç›´æ¥å®ç°å³å¯ã€‘
ç®€å•è´ªå¿ƒ ğŸŒ° PAT B1020ï¼ˆå–æœˆé¥¼P118ï¼‰ ğŸ“£ åªåœ¨ä¹é”€å”®é¢ï¼Œåªè¦æ¯æ¬¡é€‰æœ€è´µçš„å°±èƒ½è¾¾åˆ°æ€»é”€å”®é¢æœ€å¤šï¼ˆè´ªå¿ƒï¼‰ã€‚
#include&amp;lt;cstdio&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std; struct mooncake { // ç»“æ„ä½“æ•´åˆè¾“å…¥æ•°æ®  double store; // åº“å­˜  double sell; // æ€»ä»·  double price; // å•ä»·ï¼ˆåº“å­˜é™¤æ€»ä»·ï¼‰ }cake[1010]; bool cmp(mooncake a, mooncake b) { return a.price &amp;gt; b.price; } int main() { int n; // æœˆé¥¼ç§ç±»æ•°  double D; // æœˆé¥¼éœ€æ±‚é‡  scanf(&amp;#34;%d%lf&amp;#34;, &amp;amp;n, &amp;amp;D); for(int i = 0; i &amp;lt; n; i++) { // è¾“å…¥åº“å­˜  scanf(&amp;#34;%lf&amp;#34;, &amp;amp;cake[i].</description>
    </item>
    
  </channel>
</rss>
